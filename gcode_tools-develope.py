#!/usr/bin/env python 
"""
Copyright (C) 2009 Nick Drobchenko, nick@cnc-club.ru
based on gcode.py (C) 2007 hugomatic... 
based on addnodes.py (C) 2005,2007 Aaron Spike, aaron@ekips.org
based on dots.py (C) 2005 Aaron Spike, aaron@ekips.org
based on interp.py (C) 2005 Aaron Spike, aaron@ekips.org

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
"""

###
###		Gcode tools v 1.2
###

import inkex, simplestyle, simplepath
import cubicsuperpath, simpletransform, bezmisc

import os
import math
import bezmisc
import re
import copy
import sys
import time
import cmath
import numpy

_ = inkex._


def bezierparameterize(((bx0,by0),(bx1,by1),(bx2,by2),(bx3,by3))):
	#parametric bezier
	ax,ay,bx,by,cx,cy,x0,y0 = 0, 0, 0, 0, 0, 0, 0, 0 
	if (bx0,by0)==(bx1,by1) and (bx2,by2)==(bx3,by3):
		x0=bx0
		cx=bx3-bx0
		y0=by0
		cy=by3-by0
	elif (bx2,by2)==(bx3,by3) :
	    x0=bx0
	    cx = (bx1-bx0)*2
	    bx = bx0-2*bx1+bx2
	    y0=by0
	    cy = (by1-by0)*2
	    by = by0-2*by1+by2
	elif (bx0,by0)==(bx1,by1) :
	    x0=bx1
	    cx = (bx2-bx1)*2
	    bx = bx1-2*bx2+bx3
	    y0=by1
	    cy = (by2-by1)*2
	    by = by1-2*by2+by3
	else:
		x0=bx0
		y0=by0
		cx=3*(bx1-x0)
		bx=3*(bx2-bx1)-cx
		ax=bx3-x0-cx-bx
		cy=3*(by1-y0)
		by=3*(by2-by1)-cy
		ay=by3-y0-cy-by
	return ax,ay,bx,by,cx,cy,x0,y0
bezmisc.bezierparameterize = bezierparameterize

################################################################################
###
###		Styles and additional parameters
###
################################################################################

math.pi2 = math.pi*2
straight_tolerance = 0.0001
straight_distance_tolerance = 0.0001
engraving_tolerance = 0.0001
loft_lengths_tolerance = 0.0000001
options = {}
defaults = {
		'header': '%\n(Generated by gcode_tools from inkscape.) \nM3 \n',
		'footer': 'M5 \nG00 X0.0000 Y0.0000 \nM2 \n(end)\n%'
}


loft_style = {
		'main curve':	simplestyle.formatStyle({ 'stroke': '#88f', 'fill': 'none', 'stroke-width':'1', 'marker-end':'url(#Arrow2Mend)' }),
	}

biarc_style = {
		'biarc0':	simplestyle.formatStyle({ 'stroke': '#88f', 'fill': 'none', 'stroke-width':'1' }),
		'biarc1':	simplestyle.formatStyle({ 'stroke': '#8f8', 'fill': 'none', 'stroke-width':'1' }),
		'line':		simplestyle.formatStyle({ 'stroke': '#f88', 'fill': 'none', 'stroke-width':'1' }),
		'area':		simplestyle.formatStyle({ 'stroke': '#777', 'fill': 'none', 'stroke-width':'0.1' }),
	}

biarc_style_dark = {
		'biarc0':	simplestyle.formatStyle({ 'stroke': '#33a', 'fill': 'none', 'stroke-width':'1' }),
		'biarc1':	simplestyle.formatStyle({ 'stroke': '#3a3', 'fill': 'none', 'stroke-width':'1' }),
		'line':		simplestyle.formatStyle({ 'stroke': '#a33', 'fill': 'none', 'stroke-width':'1' }),
		'area':		simplestyle.formatStyle({ 'stroke': '#222', 'fill': 'none', 'stroke-width':'0.3' }),
	}

biarc_style_dark_area = {
		'biarc0':	simplestyle.formatStyle({ 'stroke': '#33a', 'fill': 'none', 'stroke-width':'0.1' }),
		'biarc1':	simplestyle.formatStyle({ 'stroke': '#3a3', 'fill': 'none', 'stroke-width':'0.1' }),
		'line':		simplestyle.formatStyle({ 'stroke': '#a33', 'fill': 'none', 'stroke-width':'0.1' }),
		'area':		simplestyle.formatStyle({ 'stroke': '#222', 'fill': 'none', 'stroke-width':'0.3' }),
	}

biarc_style_i = {
		'biarc0':	simplestyle.formatStyle({ 'stroke': '#880', 'fill': 'none', 'stroke-width':'1' }),
		'biarc1':	simplestyle.formatStyle({ 'stroke': '#808', 'fill': 'none', 'stroke-width':'1' }),
		'line':		simplestyle.formatStyle({ 'stroke': '#088', 'fill': 'none', 'stroke-width':'1' }),
		'area':		simplestyle.formatStyle({ 'stroke': '#999', 'fill': 'none', 'stroke-width':'0.3' }),
	}

biarc_style_dark_i = {
		'biarc0':	simplestyle.formatStyle({ 'stroke': '#dd5', 'fill': 'none', 'stroke-width':'1' }),
		'biarc1':	simplestyle.formatStyle({ 'stroke': '#d5d', 'fill': 'none', 'stroke-width':'1' }),
		'line':		simplestyle.formatStyle({ 'stroke': '#5dd', 'fill': 'none', 'stroke-width':'1' }),
		'area':		simplestyle.formatStyle({ 'stroke': '#aaa', 'fill': 'none', 'stroke-width':'0.3' }),
	}



################################################################################
###
###		Common functions
###
################################################################################


###
###		Just simple output function for better debugging
###
if os.path.isfile("/home/nick/output.txt") :os.remove("/home/nick/output.txt")
def print_(s=''):
	f = open("/home/nick/output.txt","a")
	f.write(str(s))
	f.write("\n")
	f.close()

#if os.path.isfile("c:\output.txt") :os.remove("c:\output.txt")
#def print_(s=''):
#	f = open("c:\output.txt","a")
#	f.write(str(s))
#	f.write("\n")
#	f.close()



###
###		Point (x,y) operations
###
class P:
	def __init__(self, x, y=None):
		if not y==None:
			self.x, self.y = float(x), float(y)
		else:
			self.x, self.y = float(x[0]), float(x[1])
	def __add__(self, other): return P(self.x + other.x, self.y + other.y)
	def __sub__(self, other): return P(self.x - other.x, self.y - other.y)
	def __neg__(self): return P(-self.x, -self.y)
	def __mul__(self, other):
		if isinstance(other, P):
			return self.x * other.x + self.y * other.y
		return P(self.x * other, self.y * other)
	__rmul__ = __mul__
	def __div__(self, other): return P(self.x / other, self.y / other)
	def mag(self): return math.hypot(self.x, self.y)
	def unit(self):
		h = self.mag()
		if h: return self / h
		else: return P(0,0)
	def dot(self, other): return self.x * other.x + self.y * other.y
	def rot(self, theta):
		c = math.cos(theta)
		s = math.sin(theta)
		return P(self.x * c - self.y * s,  self.x * s + self.y * c)
	def angle(self): return math.atan2(self.y, self.x)
	def __repr__(self): return '%f,%f' % (self.x, self.y)
	def pr(self): return "%.2f,%.2f" % (self.x, self.y)
	def to_list(self): return [self.x, self.y]	


###
###		Functions to operate with CubicSuperPath
###

def csp_at_t(sp1,sp2,t):
	bez = (sp1[1][:],sp1[2][:],sp2[0][:],sp2[1][:])
	return 	bezmisc.bezierpointatt(bez,t)

def cspbezsplit(sp1, sp2, t = 0.5):
	s1,s2 = bezmisc.beziersplitatt((sp1[1],sp1[2],sp2[0],sp2[1]),t)
	return [ [sp1[0][:], sp1[1][:], list(s1[1])], [list(s1[2]), list(s1[3]), list(s2[1])], [list(s2[2]), sp2[1][:], sp2[2][:]] ]
	
def cspbezsplitatlength(sp1, sp2, l = 0.5, tolerance = 0.01):
	bez = (sp1[1][:],sp1[2][:],sp2[0][:],sp2[1][:])
	t = bezmisc.beziertatlength(bez, l, tolerance)
	return cspbezsplit(sp1, sp2, t)	
	
def cspseglength(sp1,sp2, tolerance = 0.001):
	bez = (sp1[1][:],sp1[2][:],sp2[0][:],sp2[1][:])
	return bezmisc.bezierlength(bez, tolerance)	

def csplength(csp):
	total = 0
	lengths = []
	for sp in csp:
		for i in xrange(1,len(sp)):
			l = cspseglength(sp[i-1],sp[i])
			lengths.append(l)
			total += l			
	return lengths, total

def csp_segments(csp):
	l, seg = 0, [0]
	for sp in csp:
		for i in xrange(1,len(sp)):
			l += cspseglength(sp[i-1],sp[i])
			seg += [ l ] 

	if l>0 :
		seg = [seg[i]/l for i in xrange(len(seg))]
	return seg,l

# rebuild_csp Adds to csp control points makin it's segments looks like segs

def rebuild_csp (csp, segs, s=None):
	if s==None : s, l = csp_segments(csp)
	
	if len(s)>len(segs) : return None
	segs = segs[:]
	segs.sort()
	for i in xrange(len(s)):
		d = None
		for j in xrange(len(segs)):
			d = min( [abs(s[i]-segs[j]),j], d) if d!=None else [abs(s[i]-segs[j]),j]
		del segs[d[1]]
	for i in xrange(len(segs)):
		for j in xrange(0,len(s)):
			if segs[i]<s[j] : break
		if s[j]-s[j-1] != 0 :
			t = (segs[i] - s[j-1])/(s[j]-s[j-1])
			sp1,sp2,sp3 = cspbezsplit(csp[j-1],csp[j], t)
			csp = csp[:j-1] + [sp1,sp2,sp3] + csp[j+1:]
			s = s[:j] + [ s[j-1]*(1-t)+s[j]*t   ] + s[j:]
	return csp, s



###
###		Distance calculattion from point to arc
###

def csp_slope(sp1,sp2,t):
	bez = (sp1[1][:],sp1[2][:],sp2[0][:],sp2[1][:])
	return bezmisc.bezierslopeatt(bez,t)

def between(c,x,y):
		return x-straight_tolerance<=c<=y+straight_tolerance or y-straight_tolerance<=c<=x+straight_tolerance

def distance_from_point_to_arc(p, arc):
	P0,P2,c,a = arc
	dist = None
	p = P(p)
	r = (P0-c).mag()
	if r>0 :
		i = c + (p-c).unit()*r
		alpha = ((i-c).angle() - (P0-c).angle())
		if a*alpha<0: 
			if alpha>0:	alpha = alpha-math.pi2
			else: alpha = math.pi2+alpha
		if between(alpha,0,a) or min(abs(alpha),abs(alpha-a))<straight_tolerance : 
			return (p-i).mag(), [i.x, i.y]
		else : 
			d1, d2 = (p-P0).mag(), (p-P2).mag()
			if d1<d2 : 
				return (d1, [P0.x,P0.y])
			else :
				return (d2, [P2.x,P2.y])

def get_distance_from_csp_to_arc(sp1,sp2, arc1, arc2, tolerance = 0.01 ): # arc = [start,end,center,alpha]
	n, i = 10, 0
	d, d1, dl = (0,(0,0)), (0,(0,0)), 0
	while i<1 or (abs(d1[0]-dl[0])>tolerance and i<4):
		i += 1
		dl = d1*1	
		for j in range(n+1):
			t = float(j)/n
			p = csp_at_t(sp1,sp2,t) 
			d = min(distance_from_point_to_arc(p,arc1), distance_from_point_to_arc(p,arc2))
			d1 = max(d1,d)
		n=n*2
	return d1[0]

def get_distance_from_point_to_csp(p,sp1,sp2, tolerance = 0.01 ): 
	n, i = 10, 0
	d, dl = [None,(0,0)],[0,(0,0)]
	while i<2 or (abs(d[0]-dl[0])>tolerance and i<4):
		i += 1
		dl = d[:]	
		for j in range(n+1):
			t = float(j)/n
			cp = csp_at_t(sp1,sp2,t) 
			d = min( [(P(cp)-P(p)).mag(),t], d) if d[0]!=None else [(P(cp)-P(p)).mag(),t]
		n=n*2
	return d

def reverce_csp (csp):
	for i in range(len(csp)):
	 	n = []
	 	for j in csp[i]:
			n = [  [j[2][:],j[1][:],j[0][:]]  ] + n
	 	csp[i] = n[:]
	return csp

def cubic_solver(a,b,c,d):	
	if a!=0:
		#	Monics formula see http://en.wikipedia.org/wiki/Cubic_function#Monic_formula_of_roots
		a,b,c = (b/a, c/a, d/a)
		m = 2*a**3 - 9*a*b + 27*c
		k = a**2 - 3*b
		n = m**2 - 4*k**3
		w1 = -.5 + .5*cmath.sqrt(3)*1j
		w2 = -.5 - .5*cmath.sqrt(3)*1j
		m1 = pow(complex((m+cmath.sqrt(n))/2),1./3)
		n1 = pow(complex((m-cmath.sqrt(n))/2),1./3)
		x1 = -1./3 * (a + m1 + n1)
		x2 = -1./3 * (a + w1*m1 + w2*n1)
		x3 = -1./3 * (a + w2*m1 + w1*n1)
		return [x1,x2,x3]
	elif b!=0:
		det = c**2-4*b*d
		if det>0 :
			return [(-c+math.sqrt(det))/(2*b),(-c-math.sqrt(det))/(2*b)]
		elif d == 0 :
			return [-c/(b*b)] 	
		else :
			return [(-c+cmath.sqrt(det))/(2*b),(-c-cmath.sqrt(det))/(2*b)]
	elif c!=0 :
		return [-d/c]
	else : return []

def csp_line_intersection(l1,l2,sp1,sp2):
	dd=l1[0]
	cc=l2[0]-l1[0]
	bb=l1[1]
	aa=l2[1]-l1[1]
	if aa==cc==0 : return []
	if aa:
		coef1=cc/aa
		coef2=1
	else:
		coef1=1
		coef2=aa/cc
	bez = (sp1[1][:],sp1[2][:],sp2[0][:],sp2[1][:])
	ax,ay,bx,by,cx,cy,x0,y0=bezmisc.bezierparameterize(bez)
	a=coef1*ay-coef2*ax
	b=coef1*by-coef2*bx
	c=coef1*cy-coef2*cx
	d=coef1*(y0-bb)-coef2*(x0-dd)
	roots = cubic_solver(a,b,c,d)
	retval = []
	for i in roots :
		if type(i) is complex and i.imag==0:
			i = i.real
		if type(i) is not complex and 0<=i<=1:
			retval.append(i)
	return retval



################################################################################
###
###		Biarc function
###
###		Calculates biarc approximation of cubic super path segment
###		splits segment if needed or approximates it with straight line
###
################################################################################


def biarc(sp1, sp2, z1, z2, depth=0,):
	def biarc_split(sp1,sp2, z1, z2, depth): 
		if depth<options.biarc_max_split_depth:
			sp1,sp2,sp3 = cspbezsplit(sp1,sp2)
			l1, l2 = cspseglength(sp1,sp2), cspseglength(sp2,sp3)
			if l1+l2 == 0 : zm = z1
			else : zm = z1+(z2-z1)*l1/(l1+l2)
			return biarc(sp1,sp2,depth+1,z1,zm)+biarc(sp2,sp3,depth+1,z1,zm)
		else: return [ [sp1[1],'line', 0, 0, sp2[1], [z1,z2]] ]

	P0, P4 = P(sp1[1]), P(sp2[1])
	TS, TE, v = (P(sp1[2])-P0), -(P(sp2[0])-P4), P0 - P4
	tsa, tea, va = TS.angle(), TE.angle(), v.angle()
	if TE.mag()<straight_distance_tolerance and TS.mag()<straight_distance_tolerance:	
		# Both tangents are zerro - line straight
		return [ [sp1[1],'line', 0, 0, sp2[1], [z1,z2]] ]
	if TE.mag() < straight_distance_tolerance:
		TE = -(TS+v).unit()
		r = TS.mag()/v.mag()*2
	elif TS.mag() < straight_distance_tolerance:
		TS = -(TE+v).unit()
		r = 1/( TE.mag()/v.mag()*2 )
	else:	
		r=TS.mag()/TE.mag()
	TS, TE = TS.unit(), TE.unit()
	tang_are_parallel = ((tsa-tea)%math.pi<straight_tolerance or math.pi-(tsa-tea)%math.pi<straight_tolerance )
	if ( tang_are_parallel  and 
				((v.mag()<straight_distance_tolerance or TE.mag()<straight_distance_tolerance or TS.mag()<straight_distance_tolerance) or
					1-abs(TS*v/(TS.mag()*v.mag()))<straight_tolerance)	):
				# Both tangents are parallel and start and end are the same - line straight
				# or one of tangents still smaller then tollerance

				# Both tangents and v are parallel - line straight
		return [ [sp1[1],'line', 0, 0, sp2[1], [z1,z2]] ]

	c,b,a = v*v, 2*v*(r*TS+TE), 2*r*(TS*TE-1)
	if v.mag()==0:
		return biarc_split(sp1, sp2, z1, z2, depth)
	asmall, bsmall, csmall = abs(a)<10**-10,abs(b)<10**-10,abs(c)<10**-10 
	if 		asmall and b!=0:	beta = -c/b
	elif 	csmall and a!=0:	beta = -b/a 
	elif not asmall:	 
		discr = b*b-4*a*c
		if discr < 0:	raise ValueError, (a,b,c,discr)
		disq = discr**.5
		beta1 = (-b - disq) / 2 / a
		beta2 = (-b + disq) / 2 / a
		if beta1*beta2 > 0 :	raise ValueError, (a,b,c,disq,beta1,beta2)
		beta = max(beta1, beta2)
	elif	asmall and bsmall:	
		return biarc_split(sp1, sp2, z1, z2, depth)
	alpha = beta * r
	ab = alpha + beta 
	P1 = P0 + alpha * TS
	P3 = P4 - beta * TE
	P2 = (beta / ab)  * P1 + (alpha / ab) * P3

	def calculate_arc_params(P0,P1,P2):
		D = (P0+P2)/2
		if (D-P1).mag()==0: return None, None
		R = D - ( (D-P0).mag()**2/(D-P1).mag() )*(P1-D).unit()
		p0a, p1a, p2a = (P0-R).angle()%(2*math.pi), (P1-R).angle()%(2*math.pi), (P2-R).angle()%(2*math.pi)
		alpha =  (p2a - p0a) % (2*math.pi)					
		if (p0a<p2a and  (p1a<p0a or p2a<p1a))	or	(p2a<p1a<p0a) : 
			alpha = -2*math.pi+alpha 
		if abs(R.x)>1000000 or abs(R.y)>1000000  or (R-P0).mag<options.min_arc_radius :
			return None, None
		else :	
			return  R, alpha
	R1,a1 = calculate_arc_params(P0,P1,P2)
	R2,a2 = calculate_arc_params(P2,P3,P4)
	if R1==None or R2==None or (R1-P0).mag()<straight_tolerance or (R2-P2).mag()<straight_tolerance	: return [ [sp1[1],'line', 0, 0, sp2[1], [z1,z2]] ]
	
	d = get_distance_from_csp_to_arc(sp1,sp2, [P0,P2,R1,a1],[P2,P4,R2,a2])
	if d > options.biarc_tolerance and depth<options.biarc_max_split_depth	 : return biarc_split(sp1, sp2, z1, z2, depth)
	else:
		if R2.mag()*a2 == 0 : zm = z2
		else : zm  = z1 + (z2-z1)*(R1.mag()*a1)/(R2.mag()*a2+R1.mag()*a1)  
		return [	[ sp1[1], 'arc', [R1.x,R1.y], a1, [P2.x,P2.y], [z1,zm] ], [ [P2.x,P2.y], 'arc', [R2.x,R2.y], a2, [P4.x,P4.y], [zm,z2] ]		]





				
################################################################################
###
###		Gcode tools class
###
################################################################################




class Gcode_tools(inkex.Effect):

	def __init__(self):
		inkex.Effect.__init__(self)
		self.OptionParser.add_option("-d", "--directory",				action="store", type="string", 		dest="directory", default="/home/",				help="Directory for gcode file")
		self.OptionParser.add_option("-f", "--filename",				action="store", type="string", 		dest="file", default="-1.0",					help="File name")			
		self.OptionParser.add_option("-u", "--Xscale",					action="store", type="float", 		dest="Xscale", default="1.0",					help="Scale factor X")	
		self.OptionParser.add_option("-v", "--Yscale",					action="store", type="float", 		dest="Yscale", default="1.0",					help="Scale factor Y")
		self.OptionParser.add_option("",   "--Zscale",					action="store", type="float", 		dest="Zscale", default="1.0",					help="Scale factor Z")				
		self.OptionParser.add_option("-x", "--Xoffset",					action="store", type="float", 		dest="Xoffset", default="0.0",					help="Offset along X")	
		self.OptionParser.add_option("-y", "--Yoffset",					action="store", type="float", 		dest="Yoffset", default="0.0",					help="Offset along Y")
		self.OptionParser.add_option("",   "--Zoffset",					action="store", type="float", 		dest="Zoffset", default="0.0",					help="Offset along Z")
		self.OptionParser.add_option("-s", "--Zsafe",					action="store", type="float", 		dest="Zsafe", default="0.5",					help="Z above all obstacles")
		self.OptionParser.add_option("-z", "--Zsurface",				action="store", type="float", 		dest="Zsurface", default="0.0",					help="Z of the surface")
		self.OptionParser.add_option("-c", "--Zdepth",					action="store", type="float", 		dest="Zdepth", default="-0.125",				help="Z depth of cut")
		self.OptionParser.add_option("",   "--Zstep",					action="store", type="float", 		dest="Zstep", default="-0.125",					help="Z step of cutting")		
		self.OptionParser.add_option("-p", "--feed",					action="store", type="float", 		dest="feed", default="4.0",						help="Feed rate in unit/min")

		self.OptionParser.add_option("",   "--biarc-tolerance",			action="store", type="float", 		dest="biarc_tolerance", default="1",		help="Tolerance used when calculating biarc interpolation.")				
		self.OptionParser.add_option("",   "--biarc-max-split-depth",	action="store", type="int", 		dest="biarc_max_split_depth", default="4",		help="Defines maximum depth of splitting while approximating using biarcs.")				

		self.OptionParser.add_option("",   "--tool-diameter",			action="store", type="float", 		dest="tool_diameter", default="3",				help="Tool diameter used for area cutting")		
		self.OptionParser.add_option("",   "--max-area-curves",			action="store", type="int", 		dest="max_area_curves", default="100",			help="Maximum area curves for each area")
		self.OptionParser.add_option("",   "--area-inkscape-radius",	action="store", type="int", 		dest="area_inkscape_radius", default="-10",		help="Radius for preparing curves using inkscape")
		self.OptionParser.add_option("",   "--unit",					action="store", type="string", 		dest="unit", default="G21 (All units in mm)\n",	help="Units")
		self.OptionParser.add_option("",   "--function",				action="store", type="string", 		dest="function", default="Curve",				help="What to do: Curve|Area|Area inkscape")
		self.OptionParser.add_option("",   "--tab",						action="store", type="string", 		dest="tab", default="",							help="Means nothing right now. Notebooks Tab.")
		self.OptionParser.add_option("",   "--generate_not_parametric_code",action="store", type="inkbool",	dest="generate_not_parametric_code", default=False,help="Generated code will be not parametric.")		

		self.OptionParser.add_option("",   "--loft-distances",			action="store", type="string", 		dest="loft_distances", default="10",			help="Distances between paths.")
		self.OptionParser.add_option("",   "--loft-direction",			action="store", type="string", 		dest="loft_direction", default="crosswise",		help="Direction of loft's interpolation.")
		self.OptionParser.add_option("",   "--loft-interpolation-degree",action="store", type="float",		dest="loft_interpolation_degree", default="2",	help="Which interpolation use to loft the paths smooth interpolation or staright.")

		self.OptionParser.add_option("",   "--min-arc-radius",			action="store", type="float", 		dest="min_arc_radius", default=".1",			help="All arc having radius less than minimum will be considered as straight line")		
		
	def parse_curve(self, p):
			c = []
			if self.options.Xscale!=self.options.Yscale:
				xs,ys = self.options.Xscale,self.options.Yscale
				self.options.Xscale,self.options.Yscale = 1.0, 1.0
			else :
				xs,ys = 1.0,1.0
			### Sort to reduce Rapid distance	
			np = [p[0]]
			del p[0]
			while len(p)>0:
				end = np[-1][-1][1]
				dist = None
				for i in range(len(p)):
					start = p[i][0][1]
	
					dist = max(   ( -( ( end[0]-start[0])**2+(end[1]-start[1])**2 ) ,i)    ,   dist )
				np += [p[dist[1]][:]]
				del p[dist[1]]
			p = np[:]		
			for subpath in p:
				c += [ [    [subpath[0][1][0]*xs,subpath[0][1][1]*ys]   , 'move', 0, 0] ]
				for i in range(1,len(subpath)):
					sp1 = [  [subpath[i-1][j][0]*xs, subpath[i-1][j][1]*ys] for j in range(3)]
					sp2 = [  [subpath[i  ][j][0]*xs, subpath[i  ][j][1]*ys] for j in range(3)]
					c += biarc(sp1,sp2,0,0)
				c += [ [ [subpath[-1][1][0]*xs,subpath[-1][1][1]*ys]  ,'end',0,0] ]

			return c

	def draw_curve(self, curve, group=None, style=biarc_style):
		if group==None:
			group = inkex.etree.SubElement( self.biarcGroup, inkex.addNS('g','svg') )
		s, arcn = '', 0
		for si in curve:
			if s!='':
				if s[1] == 'line':
					inkex.etree.SubElement(	group, inkex.addNS('path','svg'), 
							{
								'style': style['line'],
								'd':'M %s,%s L %s,%s' % (s[0][0], s[0][1], si[0][0], si[0][1]),
								'comment': str(s)
							}
						)
				elif s[1] == 'arc':
					arcn += 1
					sp = s[0]
					c = s[2]
					a =  ( (P(si[0])-P(c)).angle() - (P(s[0])-P(c)).angle() )%math.pi2 #s[3]
					if s[3]*a<0: 
							if a>0:	a = a-math.pi2
							else: a = math.pi2+a
					r = math.sqrt( (sp[0]-c[0])**2 + (sp[1]-c[1])**2 )
					a_st = ( math.atan2(sp[0]-c[0],- (sp[1]-c[1])) - math.pi/2 ) % (math.pi*2)
					if a>0:
						a_end = a_st+a
					else: 
						a_end = a_st*1
						a_st = a_st+a	
					inkex.etree.SubElement(	group, inkex.addNS('path','svg'), 
						 {
							'style': style['biarc%s' % (arcn%2)],
							 inkex.addNS('cx','sodipodi'):		str(c[0]),
							 inkex.addNS('cy','sodipodi'):		str(c[1]),
							 inkex.addNS('rx','sodipodi'):		str(r),
							 inkex.addNS('ry','sodipodi'):		str(r),
							 inkex.addNS('start','sodipodi'):	str(a_st),
							 inkex.addNS('end','sodipodi'):		str(a_end),
							 inkex.addNS('open','sodipodi'):	'true',
							 inkex.addNS('type','sodipodi'):	'arc',
							'comment': str(s)
						})
			s = si
	

	def check_dir(self):
		if (os.path.isdir(self.options.directory)):
			if (os.path.isfile(self.options.directory+'/header')):
				f = open(self.options.directory+'/header', 'r')
				self.header = f.read()
				f.close()
			else:
				self.header = defaults['header']
			if (os.path.isfile(self.options.directory+'/footer')):
				f = open(self.options.directory+'/footer','r')
				self.footer = f.read()
				f.close()
			else:
				self.footer = defaults['footer']
			return True
		else: 
			inkex.errormsg(_("Directory does not exist!"))
			return False
	
	def generate_gcode(self, curve, depth):
		def c(c):
			c = [c[i] if i<len(c) else None for i in range(6)]
			if c[5] == 0 : c[5]=None
			if self.options.generate_not_parametric_code:
				s,s1 = [" X", " Y", " Z", " I", " J", " K"], ["","","","","",""]
				m,a = [self.options.Xscale,-self.options.Xscale,self.options.Zscale,self.options.Xscale,-self.options.Xscale,self.options.Zscale], [self.options.Xoffset,self.options.Yoffset,self.options.Zoffset,0,0,0]
			else :
				s,s1 = [" X[", " Y[", " Z[", " I[", " J[", " K["], [ "*#5+#8]", "*#5+#9]", "*#7+#10]", "*#5]",  "*#5]", "*#7]"]
				m,a = [1,-1,1,1,-1,1], [0,0,0,0,0,0]
			r = ''	
			for i in range(6):
				if c[i]!=None:
					r += s[i] + ("%f" % (c[i]*m[i]+a[i])) + s1[i]
			return r
		g, lg, zs, f = '', 'G00', self.options.Zsafe, " F%f"%self.options.feed if self.options.generate_not_parametric_code else "F#4" 
		for i in range(1,len(curve)):
			s, si = curve[i-1], curve[i]
			feed = f if lg not in ['G01','G02','G03'] else ''
			if s[1]	== 'move':
				g += "G00" + c([None,None,zs]) + "\nG00" + c(si[0]) + "\n"
				lg = 'G00'
			elif s[1] == 'end':
				g += "G00" + c([None,None,zs]) + "\n"
				lg = 'G00'
			elif s[1] == 'line':
				if lg=="G00": g += "G01" + c([None,None,s[5][0]+depth]) + feed +"\n"	
				g += "G01" +c(si[0]+[s[5][1]+depth]) + feed + "\n"
				lg = 'G01'
			elif s[1] == 'arc':
				r = [(s[2][0]-s[0][0]), (s[2][1]-s[0][1])]
				if (r[0]**2 + r[1]**2)*self.options.Xscale>self.options.min_arc_radius:
					r1, r2 = (P(s[0])-P(s[2])), (P(si[0])-P(s[2]))
					if abs(r1.mag()-r2.mag()) < 0.001 :
						if lg=="G00": g += "G01" + c([None,None,s[5][0]+depth]) + feed + "\n"
						g += ("G02" if s[3]>0 else "G03") + c(si[0]+[ s[5][1]+depth, (s[2][0]-s[0][0]),(s[2][1]-s[0][1]), (s[5][1]-s[5][0])/2  ]) + feed + "\n"
					else:
						r = (r1.mag()+r2.mag())/2
						g += ("G02" if s[3]>0 else "G03") + c(si[0]+[s[5][1]+depth]) + " R%f" % (r*self.options.Xscale) + feed  + "\n"
					lg = 'G02'
				else:
					if lg=="G00": g += "G01" + c([None,None,s[5][0]+depth]) + "\n"	
					g += "G01" +c(si[0]+[s[5][1]+depth]) + feed + "\n"
					lg = 'G01'
		if si[1] == 'end':
			g += "G00" + c([None,None,zs]) + "\n"
		return g
	
	
	
	def effect(self):
		global options
		options = self.options
		if len(self.options.ids)<=0:
			inkex.errormsg(_("This extension requires at least one selected path."))
			return
################################################################################
###
###		Curve to Gcode
###
################################################################################
	
		if self.options.function == 'Curve':
			if not self.check_dir() : return
			
			gcode = self.header + self.options.unit
			if not self.options.generate_not_parametric_code:
				gcode += """
#4  = %f (Feed)
#5  = %f (Scale xy)
#7  = %f (Scale z)
#8  = %f (Offset x)
#9  = %f (Offset y)
#10 = %f (Offset z)
#11 = %f (Safe distanse)
			""" % (self.options.feed, self.options.Xscale if self.options.Xscale==self.options.Yscale else 1, self.options.Zscale, self.options.Xoffset, self.options.Yoffset, self.options.Zoffset, self.options.Zsafe)

			#	Set group
			if len(self.options.ids)>0:
				self.biarcGroup = inkex.etree.SubElement( self.selected[self.options.ids[0]].getparent(), inkex.addNS('g','svg') )
				options.Group = self.biarcGroup
			p = []	
			
			for id, node in self.selected.iteritems():
				if node.tag == inkex.addNS('path','svg'):
					csp = cubicsuperpath.parsePath(node.get("d"))
					if 'transform' in node.keys():
						trans = node.get('transform')
						trans = simpletransform.parseTransform(trans)
						simpletransform.applyTransformToPath(trans, csp)
					p += csp
					 
#					gcode += '(Found path %s)\n' % node.get('id').replace('(','').replace(')','').replace('\n','')
			curve = self.parse_curve(p)
			self.draw_curve(curve)
			if self.options.Zstep == 0 : Zstep = 1
			for step in range( 0,  int(math.ceil( abs( (self.options.Zdepth-self.options.Zsurface)/self.options.Zstep )) ) ):
				Zpos = max(		self.options.Zdepth,		 self.options.Zsurface - abs(self.options.Zstep*(step+1))	)
				gcode += self.generate_gcode(curve,Zpos)
			gcode += self.footer
			try: 	
				f = open(self.options.directory+'/'+self.options.file, "w")	
				f.write(gcode)
				f.close()							
			except:
				inkex.errormsg(_("Can not write to specified file!"))
				return

################################################################################
###
###		Calculate area curves
###
################################################################################

		elif self.options.function=='Area curves' :
			if self.options.tool_diameter<=0 : 
							inkex.errormsg(_("Tool diameter must be > 0!"))				
							return
			for id, node in self.selected.iteritems():
				self.biarcGroup = inkex.etree.SubElement( node.getparent(), inkex.addNS('g','svg') )
				break
									
			for id, node in self.selected.iteritems():
				if node.tag == inkex.addNS('path','svg'):
					d = node.get('d')
					csp = cubicsuperpath.parsePath(d)
					# Finding top most point in path (min y value)
					my = (None, 0, 0, 0)
					for i in range(len(csp)):
						for j in range(1,len(csp[i])):
							ax,ay,bx,by,cx,cy,x0,y0 = bezmisc.bezierparameterize((csp[i][j-1][1],csp[i][j-1][2],csp[i][j][0],csp[i][j][1]))
							if ay == 0 :
								roots = [ -cy/(2*by) ] if by !=0 else []
							else:
								det = (2.0*by)**2 - 4.0*(3*ay*cy)
								roots = [ (-2*by+math.sqrt(det))/(6*ay), (-2*by+math.sqrt(det))/(6*ay) ] if det>=0 else []
							roots += [1,0]	
							for t in roots :
								if 0<=t<=1:
									y = ay*(t**3)+by*(t**2)+cy*t+y0  
									x = ax*(t**3)+bx*(t**2)+cx*t+x0  
									if my[0]>y or my[0] == None : 
										my = (y,i,j,t,x)
									elif my[0]==y and x>my[4] : 
										my = (y,i,j,t,x)
										
					if my[0]!=None :
 					 	subp = csp[my[1]]
 					 	del csp[my[1]]
 					 	j = my[2]
 					 	if my[3] in [0,1]:
 					 		if my[3] == 0: j=j-1
	 					 	subp[-1][2], subp[0][0] = subp[-1][1], subp[0][1]
 					 		subp = [ [subp[j][1], subp[j][1], subp[j][2]] ] + subp[j+1:] + subp[:j] + [ [subp[j][0], subp[j][1], subp[j][1]] ]
						else: 					 		
	 						sp1,sp2,sp3 = cspbezsplit(subp[j-1],subp[j],my[3])
	 						subp[-1][2], subp[0][0] = subp[-1][1], subp[0][1]
							subp = [ [ sp2[1], sp2[1],sp2[2] ] ] + [sp3] + subp[j+1:] + subp[:j-1] + [sp1] + [[ sp2[0], sp2[1],sp2[1] ]] 					 	  
 					 	csp = [subp] + csp
						# Reverce path if needed
						st,end = [],[]
						for i in range(1,len(subp)):
							pst = P( csp_at_t(subp[i-1],subp[i],.1) )
							pend = P( csp_at_t(subp[-i-1],subp[-i],.9) )
							if st==[] and (pst-P(subp[0][1])).mag()>straight_tolerance:
								st = pst - P(subp[0][1])
							if end==[] and (pend-P(subp[0][1])).mag()>straight_tolerance:
								end = pend - P(subp[0][1])
							if st!=[] and end!=[]: break
						if math.atan2(st.x,st.y) % math.pi2 < math.atan2(end.x,end.y) % math.pi2 :
							for i in range(len(csp)):
							 	n = []
							 	for j in csp[i]:
							 		n = [  [j[2][:],j[1][:],j[0][:]]  ] + n
							 	csp[i] = n[:]

								
 					 	
 					 	
					d = cubicsuperpath.formatPath(csp)
					d = re.sub(r'(?i)(m[^mz]+)',r'\1 Z ',d)
					d = re.sub(r'(?i)\s*z\s*z\s*',r' Z ',d)
					d = re.sub(r'(?i)\s*([A-Za-z])\s*',r' \1 ',d)
					r = self.options.area_inkscape_radius 							
					sign=1 if r>0 else -1
					tool_d = self.options.tool_diameter
					for i in range(self.options.max_area_curves):
						radius = - tool_d * (i+0.5) * sign
						if abs(radius)>abs(r): 
							radius = -r
							
						inkex.etree.SubElement(	self.biarcGroup, inkex.addNS('path','svg'), 
										{
											 inkex.addNS('type','sodipodi'):	'inkscape:offset',
											 inkex.addNS('radius','inkscape'):	str(radius),
											 inkex.addNS('original','inkscape'):	d,
											'style':				biarc_style_i['area']
										})
						if radius == -r : break 
	

################################################################################
###
###		Engraving
###
################################################################################

		elif self.options.function=='Engraving' :
		
################################################################################			
###			
###		To find center of cutter a system of non linear equations will be solved
###		using Newton's method 
###			
################################################################################
			def find_cutter_center((x1,y1),(nx1,ny1), sp1,sp2,t3 = .5):
				bez = (sp1[1][:],sp1[2][:],sp2[0][:],sp2[1][:])
				ax,ay,bx,by,cx,cy,dx,dy=bezmisc.bezierparameterize(bez)
				fx,fy = bezmisc.bezierpointatt(bez,t3)
				d = math.sqrt((x1-fx)**2 + (y1-fy)**2)
				t = numpy.matrix([[d/math.sqrt(nx1**2+ny1**2)],[1./2],[t3]])
				i = 0
				ta = []
				while i==0 or abs(F.sum())>engraving_tolerance and i<10:
					t1,t2,t3 = t.transpose().getA()[0]
					fx,fy = bezmisc.bezierpointatt(bez,t3)
					f1x,f1y = bezmisc.bezierslopeatt(bez,t3)
					i+=1
					F = numpy.matrix(
						[
							x1+nx1*t1-fx+t2*f1y,
							y1+ny1*t1-fy-t2*f1x,
							(nx1**2+ny1**2)*(t1**2) - (fx-x1-nx1*t1)**2 -(fy-y1-ny1*t1)**2
						])
					F1 = numpy.matrix(
								[
									[
										nx1,			f1y,		-f1x+t2*(6*ay*t3+2*by)
									],
									[
										ny1,			-f1x,		-f1y-t2*(6*ax*t3+2*bx)
									],
									[
										2*(nx1**2+ny1**2)*t1+2*nx1*(fx-x1-nx1*t1) +2*ny1*(fy-y1-ny1*t1),
														0,
																	-2*f1x*(fx-x1-nx1*t1) -2*f1y*(fy-y1-ny1*t1)
									]
								]
							)
					if numpy.linalg.det(F1)	!=0:
						t = t - numpy.linalg.inv(F1)*(F.transpose())
					else: break	
				return t.transpose().getA()[0]+[F.sum()]	


		
#			if len(self.options.ids)!=2 or self.selected[self.options.ids[0]].tag != inkex.addNS('path','svg') or self.selected[self.options.ids[1]].tag != inkex.addNS('path','svg') :
#				inkex.errormsg(_("This function requires exactly two path's!"))
#				return
			self.Group = inkex.etree.SubElement( self.selected[self.options.ids[0]].getparent(), inkex.addNS('g','svg') )
			
			d = self.selected[self.options.ids[0]].get('d')
			csp  = cubicsuperpath.parsePath(d)
			for i in range(1,len(csp)):
				csp[0] += csp[i]
			csp = csp[0]	

			print_(csp)
			"""	
			d = self.selected[self.options.ids[0]].get('d')
			d = re.sub(r'(?i)(m[^mz]+)',r'\1 Z ',d)
			d = re.sub(r'(?i)\s*z\s*z\s*',r' Z ',d)
			d = re.sub(r'(?i)\s*([A-Za-z])\s*',r' \1 ',d)
			csp  = cubicsuperpath.parsePath(d)
			csp1 = cubicsuperpath.parsePath(self.selected[self.options.ids[1]].get('d'))
			st, end = csp1[0][0][1], csp1[0][-1][1]
			for i in range(1,len(csp)):
				csp[0] += csp[i]
			csp = csp[0]	
			d = None
			for i in range(1,len(csp)):
				d = min(d, get_distance_from_point_to_csp(st,csp[i-1],csp[i])+[i]) if d!=None else get_distance_from_point_to_csp(st,csp[i-1],csp[i])+[i]
			if d==None: return
			i,t  = d[2],d[1]
			if 0.1<t<0.9:
				sp1,sp2,sp3 = cspbezsplit(csp[i-1],csp[i],t)
				csp[i-1], csp[i] = sp1[:], sp3[:]
				csp = csp[:i] + [sp2] + csp[i:]
				si = i
			elif t<=0.1: si = i-1
			else: si = i
			d = None
			for i in range(1,len(csp)):
				d = min(d, get_distance_from_point_to_csp(end,csp[i-1],csp[i])+[i]) if d!=None else get_distance_from_point_to_csp(end,csp[i-1],csp[i])+[i]
			if d==None: return
			i,t  = d[2],d[1]
			if 0.1<t<0.9:
				if i<si: si += 1 
				sp1,sp2,sp3 = cspbezsplit(csp[i-1],csp[i],t)
				csp[i-1], csp[i] = sp1[:], sp3[:]
				csp = csp[:i] + [sp2] + csp[i:]
				ei = i
			elif t<0.1: ei = i-1
			else : ei = i
			reverce_second = (ei<si)
			if ei<si:
				si, ei = ei, si

			###
			###		csp2, csp3 - right and left sides of original path
			###
			csp2 = csp[ei:-1] + [ [csp[-1][2],csp[0][1],csp[0][2]] ] + csp[1:si+1]
			csp3 = csp[si:ei+1]
			if reverce_second : csp3 = reverce_csp([csp3])[0] 
			else : csp2 = reverce_csp([csp2])[0] 
			
			s2, l = csp_segments([csp2])
			s3, l = csp_segments([csp3])
			a, segs = [], s2[:]
			
			for i in xrange(len(s3)):
				add = True
				for j in xrange(len(segs)):
					if abs(s3[i]-segs[j])<loft_lengths_tolerance: 
						add = False
						break
				if add: a += [s3[i]]
			segs = segs + a
			
#			csp2, s2 = rebuild_csp(csp2, segs, s=s2)
#			csp3, s3 = rebuild_csp(csp3, segs, s=s3)
			"""
			"""			
			inkex.etree.SubElement(	self.Group, inkex.addNS('path','svg'), 
										{
											 "d":	 cubicsuperpath.formatPath([csp2]),
											'style':				biarc_style['biarc0']
										})
			inkex.etree.SubElement(	self.Group, inkex.addNS('path','svg'), 
										{
											 "d":	 cubicsuperpath.formatPath([csp3]),
											'style':				biarc_style['biarc1']
										})
"""

			#	Create list containing normlas and points
			nl = []
			for i in range(1,len(csp)):
				n, n1 = [], []
				sp1, sp2 = csp[i-1], csp[i]
				bez = (sp1[1][:],sp1[2][:],sp2[0][:],sp2[1][:])
				for ti in [.0,.25,.75,1.]:
#	Is following string is nedded or not??? (It makes t depend on form of the curve) 
#					ti = bezmisc.beziertatlength(bez,ti)	
					x1,y1 = bezmisc.bezierpointatt(bez,ti)
					nx,ny = bezmisc.bezierslopeatt(bez,ti)
					nx,ny = -ny/math.sqrt(nx**2+ny**2),nx/math.sqrt(nx**2+ny**2) 
					n+=[ [ [x1,y1], [nx,ny], False, False, i] ] # [point coordinates, normal, is an inner corner, is an outer corner, csp's index]
					if ti==1 and i<len(csp)-1:
						bez1 = (csp[i][1][:],csp[i][2][:],csp[i+1][0][:],csp[i+1][1][:])
						nx2, ny2 = bezmisc.bezierslopeatt(bez1,0)
						nx2,ny2 = -ny2/math.sqrt(nx2**2+ny2**2),nx2/math.sqrt(nx2**2+ny2**2) 
						if abs(nx*ny2-nx2*ny)>engraving_tolerance:
 							if nx*ny2-nx2*ny >= 0:	# inner angle
								n[-1][2] = True
 							else :					# outer angle
 								a = -math.acos(nx*nx2+ny*ny2)
 								for t in [.0,.25,.75,1.]:
 									n1 += [ [ [x1,y1], [nx*math.cos(a*t)-ny*math.sin(a*t),nx*math.sin(a*t)+ny*math.cos(a*t)], False, True, i ]  ]
 				nl += [ n ] + ([ n1 ] if n1!=[] else [])
 				
 			# 	Calculate ofset points	
 			csp_points = [] 			
			for ki in range(len(nl)):
				p = []
				for ti in range(3) if ki!=len(nl)-1 else range(4):
					n = nl[ki][ti]
					x1,y1 = n[0]
					nx,ny = n[1]
					d, r = 0, None
					print_()
					print_()
					print_(n)

					inkex.etree.SubElement(	self.Group, inkex.addNS('path','svg'), 
							{
								 "d":	"M %f,%f L %f,%f" %(x1,y1,x1+nx*10,y1+ny*10),
								'style':	"stroke:#0000ff; stroke-opacity:0.46; fill:none",
						
							})				


					if ti==0 and ki>0 and nl[ki-1][-1][2] == True :
						r = 0
					else :
						for i in range(1,len(csp)):	
							print_()
							print_((i,"@@@@@@@@@@"))

							for n1 in range(5+1):
								t = float(n1)/5	
								bez1 = (csp[i-1][1][:],csp[i-1][2][:],csp[i][0][:],csp[i][1][:])
								x2,y2 = bezmisc.bezierpointatt(bez1,t)
		 						t1 = find_cutter_center((x1,y1),(nx,ny), csp[i-1],csp[i], t)
		 						x3,y3 = bezmisc.bezierpointatt(bez1,t1[2])
		 						d = t1[0]
								if n[-1]==7: print_((t1,d))
		 						if d > engraving_tolerance and 0<=t1[2]<=1 :
			 						print_("!!!")
		 							r = min(d,r) if r!=None else d	
										
						for i in range(1,len(csp)):	
							x2,y2 = csp[i][1]
							if (x1-x2 or y1!=y2) and (x2*nx - x1*nx + y2*ny - y1*ny) != 0:
								t1 = .5 * ( (x1-x2)**2+(y1-y2)**2 ) /  (x2*nx - x1*nx + y2*ny - y1*ny)
								d = abs(t1)
								r = min(d,r) if r!=None else d
								if n[-1]==7: print_((t1,d))				
					print_(("__",r))
					r = min(r, self.options.tool_diameter)
					p += [ [x1+nx*r,y1+ny*r] ]
					inkex.etree.SubElement(	self.Group, inkex.addNS('path','svg'), 
								{
									
									'style':	"fill:#ff00ff; fill-opacity:0.46; stroke:#000000",
									 inkex.addNS('cx','sodipodi'):		str(x1+nx*r),
									 inkex.addNS('cy','sodipodi'):		str(y1+ny*r),
									 inkex.addNS('rx','sodipodi'):		str(1),
									 inkex.addNS('ry','sodipodi'):		str(1),
									 inkex.addNS('type','sodipodi'):	'arc',
							
								})	
					inkex.etree.SubElement(	self.Group, inkex.addNS('path','svg'), 
								{
									
									'style':	"fill:none; fill-opacity:0.46; stroke:#000000",
									 inkex.addNS('cx','sodipodi'):		str(x1+nx*r),
									 inkex.addNS('cy','sodipodi'):		str(y1+ny*r),
									 inkex.addNS('rx','sodipodi'):		str(r),
									 inkex.addNS('ry','sodipodi'):		str(r),
									 inkex.addNS('type','sodipodi'):	'arc',
							
								})	

				if len(csp_points)>0 : csp_points[-1] += [p[0]]						 			
				csp_points += [ p ]		
				
			#	Create Path that goes through this points 
			cspm = []
			m = [[0.0, 0.0, 0.0, 1.0], [0.015625, 0.140625, 0.421875, 0.421875], [0.421875, 0.421875, 0.140625, 0.015625], [1.0, 0.0, 0.0, 0.0]]
			print_(csp_points)
			for p in csp_points:
				m = numpy.array(m)
				xi = numpy.array(p)
				sp1,sp2 = [[0.,0.],[0.,0.],[0.,0.]], [[0.,0.],[0.,0.],[0.,0.]]
				a,b,c,d = numpy.linalg.solve(m, xi).tolist()
				sp1[1], sp1[0] = d, d
				sp1[2] = c
				sp2[0] = b
				sp2[1], sp2[2] = a, a
				cspm += [sp1[:],sp2[:]]
		
				
				
			"""	
				ri, m, xi = [], [], []
				for ti in [.0,.25,.75,1.]:
					r = None
					x1,y1 = bezmisc.bezierpointatt(bez,ti)
					nx,ny = bezmisc.bezierslopeatt(bez,ti)
					if math.sqrt(nx**2+ny**2)==0 : continue
					nx,ny = -ny/math.sqrt(nx**2+ny**2),nx/math.sqrt(nx**2+ny**2)
					
					for j in range(1,len(csp)):	
						if j == i :
							for n in range(-1,10):
								t1 = 1/n							
		 						t = find_cutter_center((x1,y1),(nx,ny), csp[j-1],csp[j], t1).transpose().getA()[0]
		 						d = (nx**2+ny**2)*t1**2
		 						if d > engraving_tolerance:
		 							r = min(d,r) if r!=None else d
						else:
						
							if j==i+1 and ti==1:
								bez1 = (csp[j-1][1][:],csp[j-1][2][:],csp[j][0][:],csp[j][1][:])
		 						nx2,nx2 = bezmisc.bezierslopeatt(bez1,0)
		 						if abs(nx-nx2)>engraving_tolerance and abs(ny-ny2)>engraving_tolerance:
		 							if nx*ny2-nx2*ny > 0:	# inner angle
		 								start_is_a_corner = True
		 								r = 0
		 							else : 					# outer angle
										add_arc_with_start_r = -1
						
							for k in [j-1,j]:
								x2,y2 = csp[k][1]
								if (x1!=x2 or y1!=y2) and (x2*nx - x1*nx + y2*ny - y1*ny) != 0:
									t1 = .5 * ( (x1-x2)**2+(y1-y2)**2 ) /  (x2*nx - x1*nx + y2*ny - y1*ny)
									d = (nx**2+ny**2)*t1**2
									r = min(d,r) if r!=None else d
									
							d,t3 = get_distance_from_point_to_csp((x1,y1),csp[j-1],csp[j])
							if d==0 : t3 = 1-t3
							t = find_cutter_center((x1,y1),(nx,ny), csp[j-1],csp[j], t3).transpose().getA()[0]
							if 0<=t[2]<=1:
								t1 = t[0]
								d = (nx**2+ny**2)*t1**2
								r = min(d,r) 

					r = math.sqrt(r)
					r = min(r, self.options.tool_diameter)	
					ri+=[r]
					inkex.etree.SubElement(	self.Group, inkex.addNS('path','svg'), 
							{
								 "d":	"M %f,%f L %f,%f" %(x1,y1,x1+nx*r,y1+ny*r),
								'style':	"stroke:#0000ff; stroke-opacity:0.46; fill:none",
						
							})				

					m += [ [ti**3,3*(1-ti)*(ti**2),3*((1-ti)**2)*ti, (1-ti)**3] ]
					xi += [ [x1+nx*r,y1+ny*r] ]
				m = numpy.array(m)
				xi = numpy.array(xi)
				sp1,sp2 = [[0.,0.],[0.,0.],[0.,0.]], [[0.,0.],[0.,0.],[0.,0.]]
				a,b,c,d = numpy.linalg.solve(m, xi).tolist()
				sp1[1], sp1[0] = d, d
				sp1[2] = c
				sp2[0] = b
				sp2[1], sp2[2] = a, a
				cspm += [sp1[:],sp2[:]]
#				if cspm==[] : cspm = [sp1[:],sp2[:]]
#				else : 
#					cspm[-1][2] = sp1[2][:]
#					cspm += [ sp2 ]
#				print_(cspm	)
					
				"""	
			node =  inkex.etree.SubElement(	self.Group, inkex.addNS('path','svg'), 										{
										 "d":	 cubicsuperpath.formatPath([cspm]),
										'style':				biarc_style_i['biarc1']
									})
								
#					inkex.etree.SubElement(	self.Group, inkex.addNS('path','svg'), 
#								{
#									 "d":	 cubicsuperpath.formatPath([csp3]),
#									'style':	"fill:#ff00ff; fill-opacity:0.46; stroke:#000000",
#									 inkex.addNS('cx','sodipodi'):		str(x2),
#									 inkex.addNS('cy','sodipodi'):		str(y2),
#									 inkex.addNS('rx','sodipodi'):		str(1),
#									 inkex.addNS('ry','sodipodi'):		str(1),
#									 inkex.addNS('type','sodipodi'):	'arc',
#							
#								})	
#					inkex.etree.SubElement(	self.Group, inkex.addNS('path','svg'), 
#								{
#									 "d":	 cubicsuperpath.formatPath([csp3]),
#									'style':	"fill:#ff00ff; fill-opacity:0.46",
#									 inkex.addNS('cx','sodipodi'):		str(x1+nx*r),
#									 inkex.addNS('cy','sodipodi'):		str(y1+ny*r),
#									 inkex.addNS('rx','sodipodi'):		str(r),
#									 inkex.addNS('ry','sodipodi'):		str(r),
#									 inkex.addNS('type','sodipodi'):	'arc',
#							
#								})	

			
#			cspm = []
#			for i in range(len(csp2)):
#				cspm += [[]]
#				for j in range(len(csp2[i])):
#					print_(cspm)
#					print_((i,j,len(csp2),len(csp3)))
#					cspm[i] += [ [(csp2[i][j][0]+csp3[i][j][0])/2, (csp2[i][j][1]+csp3[i][j][1])/2] ]
#	
#			l, w = 0, [[0,0]]
#			for i in range(1,len(cspm)):
#				l += cspseglength(cspm[i-1],cspm[i])
#				d = None
#				for j in xrange(1,len(csp2)):
#					d = min(d, get_distance_from_point_to_csp(end,csp2[j-1],csp2[j])+[j]) if d!=None else get_distance_from_point_to_csp(end,csp[j-1],csp2[j])+[j]
#				w += [
#					[ ( d[1] )/2,l]
#					]	
#					
					
#				inkex.etree.SubElement(	self.Group, inkex.addNS('path','svg'), 
#									{
#										 "d":	 "M %f,%f L %f,%f L %f,%f" % (csp2[i][1][0],csp2[i][1][1],cspm[i][1][0],cspm[i][1][1],csp3[i][1][0],csp3[i][1][1]),
#										'style':				biarc_style['biarc0']
#									})
#			d, d1 = "M 0,0 ",""
#			for i in xrange(len(w)):
#				d  += " L %f,%f" % (w[i][1],w[i][0])
#				d1 += " L %f,%f" % (w[-i-1][1],-w[-i-1][0])
#			d = d+d1+" L 0,0"	
#			
#			inkex.etree.SubElement(	self.Group, inkex.addNS('path','svg'), 
#										{
#											 "d":	 d,
#											'style':				biarc_style['biarc0']
#										})
			
				
		
#			node =  inkex.etree.SubElement(	self.Group, inkex.addNS('path','svg'), 										{
#											 "d":	 cubicsuperpath.formatPath([cspm]),
#											'style':				biarc_style_i['biarc1']
#										})
			
					
e = Gcode_tools()
e.affect()					
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	
